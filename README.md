# Лабораторная работа №2
# Использование метода дискретных особенностей для моделирования аэродинамических процессов

## Вступление

Теоретическая часть описана в [отчете](/report/report.pdf).

## Использование программы

Основными инструментами являются класс *Engine* и функция *main_animation_with_params* из файла [*main.py*](main.py). В классе *Engine* реализован сам модельный процесс, а функция отвечает за создание анимации.

### Использование класса *Engine*

#### Инициализация объекта *Engine*

Конструктор класса принимает такие аргументы:

- *V_inf* - комплексное число. Его модуль должен быть равен 1. Эта переменная задает постоянную скорость течения.
- *obstacle_func* - функция, которая возвращает точки преграды. Подробнее описана ниже.
- *x0* - действительное число, один из аргументов функции *obstacle_func*.
- *y0* - действительное число, один из аргументов функции *obstacle_func*.
- *M* - натуральное число, количество точек дискретных особенностей.
- *delta* - действительное положительное малое число, используется для вычисления шага времени и при вычислении величины R_0i.
- *reverse* - булевый тип, модифицирует результат функции *obstacle_func*.

##### Требования и пример функции *obstacle_func*

Функция *obstacle_func* должна принимать в виде аргументов 2 действтельных числа *x0*, *y0*. Возвращать функция должна *numpy* массив вида *[[x_0, x_1,..., x_m], [y_0, y_1,..., y_m]]*, то есть размеров *(2, m)*. 

Функция *obstacle_func* задает незамкнутое препядствие, по сути функция задает последовательность точек ломаной. Начало препядствия находится в точке *(x_0, y_0)*, последовательно соединив отрезками точки результата функции, получим препядствие. Такой вид выходного массива был выбран из удобства его подстановки в функцию рисования графика.

Пример функции:
```python
def create_obstacle_plate(x0,y0):
    return np.array([[x0, x0], [y0 - 0.5, y0 + 0.5]])
```

Желательно, чтобы длина препядствия была равна 1, но программы будет работать и с иной длиной.
```python
def create_obstacle_5(x0,y0):
    x  = [x0, x0+0.5, x0+0.5, x0, x0, x0+0.5]
    y = [y0, y0, y0+0.5, y0+0.5, y0+0.75, y0+0.75]
    return np.array([x,y])
```

Важно учитывать параметр *reverse* при создании объекта *Engine*. Этот параметр изменяет порядок точек результата функции *obstacle_func* на обратный. Это изменяет направление обхода препядствия и соответственно направление нормалей.

![Рисунок препядствия с *reverse = True*](/pictures/Obstacle%20example%20reverse.png "Рисунок препядствия с *reverse = True*")

Видим рисунок препядствия с параметром *reverse = True*.

![Рисунок препядствия с *reverse = Flase*](/pictures/Obstacle%20example.png "Рисунок препядствия с *reverse = False*")

Видим рисунок препядствия с параметром *reverse = False*. Синим отмечены точки дискретных особенностей, красным - точки колокации из которых выходят нормали.

#### Методы и атрибуты объекта *Engine*

- Методы:
  - *V_t(z)* - функция скорости в данный момент. Принимает *numpy* массив комплексных чисел, в которых необходимо вычислить скорость. Возвращает *numpy* массив скоростей в точках *z* разбитый на составляющие по *x* и *y*. То есть размер массива - *(2, z.shape)*.
  - *update()* - функция обновления процесса.
- Атрибуты:
  - *p_dots* - одномерный *numpy* массив комлексных точек. Эти конечные и угловые точки препядствия, из этих точек будут отрываться вихревые точки.
  - *Lv_dots* - двухмерный *numpy* массив комплексных точек. Это вихревые точки, на каждом шаге их количество растет. Первая координата массива - это индекс точки *p_dots* от которой оторвалась вихревая точка, вторая коодината это номер точки, причем чам меньше номер тем позже оторвалась точка. 
  - *obstacle* - *numpy* массив, результат работы *obstacle_func*.
  - *n* - количество сделаных шагов.
  - *t* - пройденное время.
  - *tay* - размер последнего шага по времени.
  
### Использование функции *main_animation_with_params*

Функция создает и сохраняет анимацию процесса.

#### Аргументы функции

- *name* - строка, название файла, который создаст функция. Файл должен быть с расширением *.gif*.
- *frames* - натуральное число, количество кадров анимации, каждый кадр соответсвует одному шагу процесса.
- *start_anim_from_moment* - неотрицательное целое число, номер шага, начиная с которого, будет записываться анимация.
- *scopes* - список(кортеж), размеры поля анимации, задается таким образом *((x_min, x_max),(y_min, y_max))*.
- *step* - натуральное число, задает плотость сетки скоростей.
- *figsize* - параметр для инициализации объекта *plt.figure(figsize = figsize)*. Задает размер картинки, но хороший результат получается, даже если этот параметр не указывать.
- *show_steps* - вывод логов выполнения функции.
- Далее идут атрибуты для инициализации объекта *Engine*.

## Результаты

### Расмотрим преграду в виде пластинки.
Результат при скорости V_inf = cos(pi/4) + i*sin(pi/4).
```python
size =1.5
scopes = ((-1*size, 5*size),(-1*size, 5*size))
V_inf= np.cos(np.pi/4) + 1j*np.sin(np.pi/4)
main_animation_with_params(V_inf = V_inf, frames=500,scopes=scopes, obstacle_func=create_obstacle_plate,
                            name = name, figsize=(6,6))
```

![/gifs/plate1.gif](/gifs/plate1.gif )

На анимации четко видна периодичность отрывов вихревых точек от преграды.

Рассмотрим теперь скорость V_inf = 1 + 0*i. При такой скорости красивый *"хвост"* появляется только через несколько сотен шагов. Поэтому выведем анимацию начиная с некоторого шага.
```python
size =1.5
scopes = ((-1*size,10*size),(-3*size, 3*size))
V_inf= 1 + 0j
main_animation_with_params(V_inf = V_inf, frames=500,start_anim_from_moment=450,scopes=scopes,
                            obstacle_func=create_obstacle_plate, name = name, figsize= (11,6))
```
![/gifs/plate2.gif](/gifs/plate2.gif )

### Расмотрим преграду в виде 1.

Результат при скорости V_inf = cos(pi/4) + i*sin(pi/4).
```python
size =1.5
scopes = ((-1*size,5*size),(-1*size, 5*size))
V_inf= np.cos(np.pi/4) + 1j*np.sin(np.pi/4)
main_animation_with_params(V_inf = V_inf, frames=500,scopes=scopes, obstacle_func=create_obstacle_1,
                            name = name, figsize=(6,6))
```

![/gifs/one1.gif](/gifs/one1.gif )


Рассмотрим теперь скорость V_inf = 1 + 0*i.

```python
size =1.5
scopes = ((-1*size,10*size),(-3*size, 3*size))
V_inf= 1 + 0j
main_animation_with_params(V_inf = V_inf, frames=500,scopes=scopes, obstacle_func=create_obstacle_1,
                            name = name, figsize= (11,6))
```

![/gifs/one2.gif](/gifs/one2.gif )

Можно заметить, что скорость движения точек на анимации непостоянна, это происходить из-за того, что шаг по времени *tay* непостоянен.

## Ошибки в лабораторной

К сожалению, в программе есть ошибки. Они связаны с условием непроницаемости границы. Ошибка периодически возникает при отрыве вихревой точки от угловой точки преграды, когда скорость в угловой точки направленна внутрь угла. Ошибка возникает, потому что я не провожу проверку скорости точек, которые отрываются на текущем шаге, точка может просочится сквозь преграду.

Вот пример такой ошибки.
```python
size =1.5
scopes = ((-1*size,1*size),(-1*size, 1*size))
V_inf= 1 + 0j
main_animation_with_params(V_inf = V_inf, frames=50, start_anim_from_moment=190,scopes=scopes, 
                            obstacle_func=create_obstacle_1, name = name)
```

![/gifs/error_one.gif](/gifs/error_one.gif )

Как видим, иногда скорость в уголовой точке бывает направленна внутрь угла и туда попадает точка, но это единичные случаи, которые не сильно влияют на общую картину.
